## JAVA 面试题

+ 面向对象的特征有哪些方面？

  封装，继承，多态，抽象

  **封装：**

  把属性私有化封装在一个类里面，只能通过方法去访问。

  **继承**

  子类继承父类，从而继承父类的方法和属性。

  **多态**

  多态分为操作符的多态和类的多态。类的多态指父类引用指向子类对象，并且有继承，有重写。

  **抽象**

  比如一个英雄类，**抽象**出了name,hp这些属性，使得开发过程中更加易于理解

  

+ String是最基本的数据类型吗？

  String是类类型，不是基本类型。
  [基本类型]有八种
  这八种基本类型分别是：
  整型 （4种）
  字符型 （1种）
  浮点型 （2种）
  布尔型（1种）

  

+ int 和 Integer 有什么区别？

  int是基本类型32位长度的整数

  Integer是类类型，是int的封装类

  int和Integer之间可以通过自动装箱 自动拆箱 互相转换

  

+ String 和StringBuffer的区别？

  String是immutable的,其内容一旦创建好之后，就不可以发生改变。
  StringBuffer 是可以变长的，内容也可以发生改变
  改变的原理是StringBuffer内部采用了字符数组存放数据，在需要增加长度的时候，创建新的数组，并且把原来的数据复制到新的数组这样的办法来实现。
  更多细节可以参考 模仿StringBuffer的 MyStringBuffer类是如何实现的。

  

+ 运行时异常与一般异常有何异同？

  [运行时异常]又叫做非可查异常，在编译过程中，不要求必须进行显示捕捉
  [一般异常]又叫做可查异常，在编译过程中，必须进行处理，要么捕捉，要么通过throws抛出去

  

+ 说出ArrayList,Vector, LinkedList的存储性能和特性

  ArrayList和Vector：

  ​	两者都继承抽象类AbstractList，但是Vector是线程安全的，而ArrayList是非线程安全的

  ArrayList和LinkedList的区别

  ​	ArrayList 是数组结构，所以定位很快，但是插入和删除很慢

  ​	LinkedList 是双向链表结构，所以插入和删除很快，但是定位很慢

  

+ Collection 和 Collections的区别

  Collection是接口，是List和Set的父接口
  Collections是工具类，提供了排序，混淆等等很多实用方法

  

+ &和&&的区别

  & 有两个作用，分别是 位与 和 逻辑与

  && 就是逻辑与
  作为逻辑与， **& 和 && 分别表示长路与和短路与**
  **长路与** 两侧，都会被运算
  **短路与** 只要第一个是false，第二个就不进行运算了

  

+ HashMap和Hashtable的区别

  HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式

  区别1：
  	HashMap可以存放 null
  	Hashtable不能存放null
  区别2：
  	HashMap不是线程安全的类
  	Hashtable是线程安全的类

  

+ final, finally, finalize的区别

  final

  ​	final修饰类，方法，基本类型变量，引用的时候分别有不同的意思
  ​	修饰类 表示该类不能被继承
  ​	修饰方法 表示该方法不能被重写
  ​	修饰基本类型变量 表示该变量只能被赋值一次
  ​	修饰引用 表示该引用只有一次指向对象的机会

  finally

  ​	finally 是用于异常处理的场面，无论是否有异常抛出，都会执行

  finalize

  ​	finalize是Object的方法，所有类都继承了该方法。 当一个对象满足垃圾回收的条件，并且被回收的时候，其finalize()方法就会被调用

+ Error和Exception有什么区别?

  Error和Exception都实现了Throwable接口

  Error指的是JVM层面的错误，比如内存不足OutOfMemoryError

  Exception指的是代码逻辑的异常，比如下标越界OutOfIndexException

  

+ abstract class和interface有什么区别?

  abstract class 抽象类和interface接口的区别：

  使用方式：
  	**抽象类只能够通过继承被使用**
  	接口必须通过**实现**被使用

  实现方法：
  	抽象类不仅可以提供抽象方法，也可以提供实现方法
  	接口只能提供抽象方法，不能提供实现方法。 但是在JAVA8版本开始，接口可以提供实现方法了，前提	是要在方法前加一个default修饰符

  

+ heap和stack有什么区别？

  heap: 堆

  stack: 栈

  存放的内容不一样：
  heap: 是存放对象的
  stack: 是存放基本类型(int, float, boolean 等等)、引用(对象地址)、方法调用

  存取方式不一样：
  heap: 是自动增加大小的，所以不需要指定大小，但是存取相对较慢
  stack: 是固定大小的，并且是FILO 先入后出的顺序，并且存取速度比较快

- GC是什么? 为什么要有GC?

  GC是Garbage Collection的缩写，即**垃圾回收**
  这里所谓的垃圾，指的是那些不再被使用的对象，JVM的垃圾回收机制使得开发人员从无聊、容易犯错的手动释放内存资源的过程中解放出来。
  开发人员可以**更加专注的进行业务功能的开发**，而资源回收的工作交由更加专业的垃圾回收机制自动完成。



- short s1 = 1; s1 = s1 + 1;有什么错?

  short s1 = 1; 这一句没有错误，编译器会自动把1这个整数处理为short.
  s1 = s1 + 1; 右侧的表达式会返回一个Int类型的整数，再把这个int类型的整数赋给short类型的s1的时候，就会出现强制转换错误。



- 接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类（concrete class）？

  接口是否可继承接口?
  可以，比如List 就继承了接口Collection

  抽象类是否可实现(implements)接口?
  可以，比如 MouseAdapter鼠标监听适配器是一个抽象类，并且实现了MouseListener接口

  抽象类是否可继承实体类（concrete class）？
  可以，所有抽象类，都继承了Object



- List, Set, Map是否继承自Collection接口?

  List 和 Set 继承了Collection接口

  但是Map和Collection之间没有继承关系，因为一个是键值对容器，一个是单值容器，无法兼容

  ![List, Set, Map是否继承自Collection接口?](https://stepimagewm.how2j.cn/1960.png)





- 数组有没有length()这个方法? String有没有length()这个方法？

  数组获取长度的手段是 .length 属性

  String获取长度的手段是 length()方法

  集合获取长度的手段是 size()方法

  文件获取长度的手段是 length()方法



- Set里的元素是不能重复的，那么用什么方法来区分重复与否呢？

  以HashSet为例，判断重复的逻辑是：

  1. 首先看hashcode是否相同，如果不同，就是不重复的
  2. 如果hashcode一样，再比较equals，如果不同，就是不重复的，否则就是重复的。



- 构造器Constructor是否可被override?是否可以继承String类?

​     子类不能继承父类的构造方法，所以就不存在重写父类的构造方法。



- 垃圾回收的优点和原理。并考虑2种回收机制。

  与C语言开发人员需要手动进行内存资源的释放不同，Java提供垃圾回收机制，自动进行GC，将开发人员从容易犯错的内存资源管理中解放出来。

  原理：当某个一个对象，没有任何引用指向它的时候，那么它就满足垃圾回收的条件，在适当的时候，JVM虚拟机进行GC将其回收，释放空间，以供后续再利用。

  两种常见的回收机制：

  1. 定时回收
     每隔30分钟进行一次回收，这种机制的弊端是如果垃圾产生的比较快，有可能30分钟之内垃圾已经把内存占用光了，导致性能变慢

  2. 当垃圾占到某个百分比的时候，进行回收
     比如，当垃圾占到70%的时候，进行回收。 这种机制的弊端是，如果垃圾产生的频率很快，那么JVM就必须高频率的进行垃圾回收。 而在垃圾回收的过程中， JVM会停顿下来，只做垃圾回收，而影响业务功能的正常运行。

  一般说来 JVM会采用两种机制结合的方式进行垃圾回收。与C语言开发人员需要手动进行内存资源的释放不同，Java提供垃圾回收机制，自动进行GC，将开发人员从容易犯错的内存资源管理中解放出来。

  原理：当某个一个对象，没有任何引用指向它的时候，那么它就满足垃圾回收的条件，在适当的时候，JVM虚拟机进行GC将其回收，释放空间，以供后续再利用。

  两种常见的回收机制：

  1. 定时回收
     每隔30分钟进行一次回收，这种机制的弊端是如果垃圾产生的比较快，有可能30分钟之内垃圾已经把内存占用光了，导致性能变慢

  2. 当垃圾占到某个百分比的时候，进行回收
     比如，当垃圾占到70%的时候，进行回收。 这种机制的弊端是，如果垃圾产生的频率很快，那么JVM就必须高频率的进行垃圾回收。 而在垃圾回收的过程中， JVM会停顿下来，只做垃圾回收，而影响业务功能的正常运行。

  一般说来 JVM会采用两种机制结合的方式进行垃圾回收。





- 你所知道的集合类都有哪些？主要方法？

  常见的集合
  ArrayList,LinkedList,HashSet,HashMap,TreeSet 等等
  常见方法：
  size()
  add()
  remove()
  等等



- 关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？

  throws 用在方法声明上面，表示该方法有可能抛出某个异常
  throw 抛出一个指定的异常
  try catch 在try中有可能会抛出某个异常，一旦某个异常抛出后，就会在catch中进行捕捉，他俩**一般说来**都是成对出现的。
  finally 表示无论是否捕捉住异常，都会执行



- java中实现多态的机制是什么？

  类的多态的条件：

  1. 父类（接口）引用指向子类对象
  2. 方法有重写



- 静态变量和实例变量的区别？

  静态变量 直接通过类就可以访问，无需实例

  实例变量 比如通过类的某个具体实例，才可以访问



- 在JAVA中，如何跳出当前的多重嵌套循环？

  在外部循环的前一行，加上标签
  在break的时候使用该标签
  即能达到结束多重嵌套循环的效果

  ```java
  public class HelloWorld {
      public static void main(String[] args) {
             
          //打印单数    
          outloop: //outloop这个标示是可以自定义的比如outloop1,ol2,out5
          for (int i = 0; i < 10; i++) {
                
              for (int j = 0; j < 10; j++) {
                  System.out.println(i+":"+j);
                  if(0==j%2) 
                      break outloop; //如果是双数，结束外部循环
              }
                
          }
            
      }
  }
  ```



- List、Map、Set三个接口，存取元素时，各有什么特点？

  List 是有顺序的，并且可以重复
  Set 是无序的，不可以重复
  Map 保存数据的方式是键值对

- 内部类可以引用外部类的成员吗？有没有什么限制？

  可以使用
  如果是非静态内部类，可以使用外部类的所有成员
  如果是静态内部类，只能使用外部类的静态成员



- 多线程有几种实现方法,都是什么？

  通常来讲，Java 创建一个线程有三种方式

  1. 继承一个Thread类
  2. 实现Runnable接口
  3. 匿名内部类



- sleep() 和 wait() 有什么区别?

  首先sleep和wait之间没有任何关系

  sleep 是Thread类的方法，指的是**当前线程暂停**。

  wait 是Object类的方法， 指的占用**当前对象的线程临时释放对当前对象的占用**，以使得其他线程有机会占用当前对象。 所以调用wait方法一定是在synchronized 中进行



- 说出数据连接池的工作机制是什么?

  数据库连接池原理：
  因为创建连接和关闭连接的行为是非常耗时的，会显著降低软件的性能表现。解决办法就是先创建 n 条数据库连接Connection，循环使用，但是不进行关闭，这样再执行SQL语句，就不需要额外创建连接了，直接使用现成的连接就可以了，从而节约了创建连接和关闭连接的时间开销。



- 简述synchronized和java.util.concurrent.locks.Lock的异同 ？

  1. Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，Lock是代码层面的实现。

  2. Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized不行，会一根筋一直获取下去。 借助Lock的这个特性，就能够规避死锁，synchronized必须通过谨慎和良好的设计，才能减少死锁的发生。

  3. synchronized在发生异常和同步块结束的时候，会自动释放锁。而Lock必须手动释放， 所以如果忘记了释放锁，一样会造成死锁。