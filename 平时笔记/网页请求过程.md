1. 解析URL：浏览器确定Web服务器和文件名

   

   ![图片](D:\Pictures\笔记资料\图片.png)

2. 生成HTTP请求

   

   ![HTTP请求](D:\Pictures\笔记资料\HTTP请求.png)

3. DNS域名解析：查询真实地址，查询服务器域名对应的IP地址。DNS专门保存了Web服务器域名与IP的对应关系。

   

   ![DNS解析过程](D:\Pictures\笔记资料\DNS解析过程.png)

4. 协议栈

   通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的**协议栈**、

   

   ![协议栈](D:\Pictures\笔记资料\协议栈.png)

   应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责

   收发数据的 TCP 和 UDP 协议，它们两会接受应用层的委托执行收发数据的操作。

5. TCP

   

![TCP 报文头部的格式](D:\Pictures\笔记资料\TCP 报文头部的格式.png)

源端口号，目的端口号：数据发送目的地

序号：解决数据包乱序问题

确认序列：确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送

达，这个是为了解决不丢包的问题

SYN：发起一个连接

ACK：回复

窗口大小：TCP 要做**流量控制**，通信双方各声明一个窗口（缓存大小），标识自己

当前能够的处理能力



三次握手：HTTP传输数据之前，首先需要与TCP建立连接。TCP连接的建立，就称为三次握手。

![三次握手](D:\Pictures\笔记资料\三次握手.png)

- 一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN状态。

- 然后客户端主动发起连接 SYN ，之后处于 SYN-SENT 状态。

- 服务端收到发起的连接，返回 SYN ，并且 ACK 客户端的 SYN ，之后处于 SYN-RCVD 状态。

- 客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK ，之后处于

ESTABLISHED 状态，因为它一发一收成功了。

- 服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也一发一收了。



TCP分割数据：

![TCP分割数据](D:\Pictures\笔记资料\TCP分割数据.png)



6. TCP报文生成：在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。

   

   ![TCP报文与HTTP报文区别](D:\Pictures\笔记资料\TCP报文与HTTP报文区别.png)



7. IP：使用IP模块将数据封装成网络包

   

   ![IP报文格式](D:\Pictures\笔记资料\IP报文格式.png)

   

   源地址IP：客户端输出的IP地址

   目标地址：通过DNS域名解析得到的Web服务器IP地址

8. IP报文生成：

   加上IP头部的数据包：

   

   ![网络包](D:\Pictures\笔记资料\网络包.png)

   

9. 两点传输：MAC

   生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 **MAC** **头部**。

   MAC包头格式：

   

   ![MAC包头格式](D:\Pictures\笔记资料\MAC包头格式.png)

   发送方MAC地址，接收方MAC地址：用于两点之间的传输。

   但MAC 发送方和接收方如何确认呢？

   **发送方**的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。

   **接收方**的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。

   所以先得搞清楚应该把包发给谁，这个只要查一下**路由表**就知道了。在路由表中找到相匹配的条目，然后把包发给 Gateway 列中的 IP 地址就可以了。

10. ARP协议：找到路由器的MAC地址

    

    ![ARP协议](D:\Pictures\笔记资料\ARP协议.png)

    

    ARP 协议会在以太网中以**广播**的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的MAC 地址告诉我”。

    然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。

    如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。

    这边我们有一个问题：每次都要广播获取，这不是很麻烦吗？

    这一点不用担心，操作系统会把本次查询结果放到一块叫做 **ARP** **缓存**的内存空间留着以后用，不过缓存的时间就几分钟。

    ARP缓存：

    先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用ARP 缓存中的地址。

    而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。



​	到达这一步的网络包：



![加上了 MAC 头部的数据包](D:\Pictures\笔记资料\加上了 MAC 头部的数据包.png)

​	

11. 出口：网卡

    IP 生成的网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要

    将**数字信息转换为电信号**，才能在网线上传输，也就是说，这才是真正的数据发送过程。

    负责执行这一操作的是**网卡**，要控制网卡还需要靠**网卡驱动程序**。

    网卡驱动从 IP 模块获取到包之后，会将其**复制**到网卡内的缓存区中，接着会在其开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。

    

    ![网卡负责的部分](D:\Pictures\笔记资料\网卡负责的部分.png)



​	起始帧分界符：是一个用来表示包起始位置的标记

​	末尾的 FCS （帧校验序列）：用来检查包传输过程是否有损坏

​	最后网卡会将包转为电信号，通过网线发送出去



12. 送别者 —— 交换机

    交换机的设计是将网络包**原样**转发到目的地。交换机工作在MAC 层，也称为**二层网络设备**。

    交换机的包接收操作：

    首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。

    然后通过包末尾的 FCS 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。

    计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，**交换机的端口不具有** **MAC** **地址**。

    将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。

    交换机的 MAC 地址表主要包含两个信息：

    - 一个是设备的 MAC 地址，

    - 另一个是该设备连接在交换机的哪个端口上。



13. 出境大门 —— 路由器

    路由器与交换机的区别：
    
    - **路由器**是基于 IP 设计的，俗称**三层**网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；
    
    - 交换机是基于以太网设计的，俗称二层网络设备，交换机的端口不具有MAC地址。
    
    路由器的基本原理：
    
    路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。
    
    当转发包时，首先路由器端口会接收发给自己的以太网包，然后**路由表**查询转发目标，再由相应的端口
    
    作为发送方将以太网包发送出去。
    
    
    
14. 服务器和客户端

    

    ![服务器和客户端](D:\Pictures\笔记资料\服务器和客户端.png)

    

    数据包到达服务器后，服务器先扒开数据包的MAC头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。

    接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。

    于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中

    然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口

    号。

    于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。

    服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。

    穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。

    最后跳到了客户端的城门把手的路由器，路由器扒开 IP 头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。

    客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！

    于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！

    最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。

    

> 参考：图解网络

